#!/usr/bin/env nix-shell
#!nix-shell -i bash -p git jq nixVersions.latest parallel
# shellcheck shell=bash
set -euo pipefail

get_physical_cores() {
	local cores=1
	if [[ $OSTYPE == "darwin"* ]]; then
		# macOS
		cores=$(sysctl -n hw.physicalcpu 2>/dev/null || echo 1)
	elif [[ $OSTYPE == "linux-gnu"* ]]; then
		# Linux - try nproc first, then fall back to parsing /proc/cpuinfo
		if command -v nproc >/dev/null 2>&1; then
			cores=$(nproc 2>/dev/null || echo 1)
		else
			cores=$(grep -c "^processor" /proc/cpuinfo 2>/dev/null || echo 1)
		fi
	elif [[ $OSTYPE == *"bsd"* ]]; then
		# BSD
		cores=$(sysctl -n hw.ncpu 2>/dev/null || echo 1)
	fi
	echo "$cores"
}

get_ram_gb() {
	local ram_bytes=0
	local ram_gb=8
	if [[ $OSTYPE == "darwin"* ]]; then
		# macOS - hw.memsize returns bytes
		ram_bytes=$(sysctl -n hw.memsize 2>/dev/null || echo 0)
	elif [[ $OSTYPE == "linux-gnu"* ]]; then
		# Linux - MemTotal in /proc/meminfo is in kB
		ram_bytes=$(awk '/MemTotal/ {print $2 * 1024}' /proc/meminfo 2>/dev/null || echo 0)
	elif [[ $OSTYPE == *"bsd"* ]]; then
		# BSD - hw.physmem returns bytes
		ram_bytes=$(sysctl -n hw.physmem 2>/dev/null || echo 0)
	fi

	if [ "$ram_bytes" -gt 0 ]; then
		# Convert bytes to GB (1 GB = 1073741824 bytes)
		ram_gb=$((ram_bytes / 1073741824))
	fi
	echo "$ram_gb"
}

SYSTEM="${SYSTEM:-}"
BOOT_STAGES=""
BOOT_STAGE_MINIMUM=""
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/nix-eval-diffs"
WORKTREE_DIR="/tmp/nix-eval-diff-worktree-$$"

if [ -z "${MAX_JOBS:-}" ]; then
	cores=$(get_physical_cores)
	ram_limit=$(($(get_ram_gb) / 8))
	# Ensure ram_limit is at least 1
	ram_limit=$((ram_limit > 0 ? ram_limit : 1))
	# Take minimum of cores and ram_limit
	MAX_JOBS=$((cores < ram_limit ? cores : ram_limit))
	# Ensure MAX_JOBS is at least 1
	MAX_JOBS=$((MAX_JOBS > 1 ? MAX_JOBS : 1))
fi

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

cleanup() {
	if [ -d "$WORKTREE_DIR" ]; then
		git worktree remove -f "$WORKTREE_DIR" 2>/dev/null || true
	fi
}
trap cleanup EXIT

usage() {
	cat <<EOF
Usage: $0 [OPTIONS] <commit-range>

Compare Nix package evaluations across a commit range.
Caching uses git tree hashes - rebased/amended commits reuse cache if content unchanged.

OPTIONS:
    --system SYSTEM          System to evaluate (default: builtins.currentSystem)
    --jobs N                 Max parallel evaluations (default: min(RAM/8GB, cores))
    --boot-stages ATTRS      Comma-separated attrPaths to diff across stdenv boot stages
                             (e.g., "llvmPackages.clang,stdenv.cc")
    --boot-stage-minimum N   Include only boot stages N and above (e.g., 2 for stages 2-7)
    --clear-cache            Clear cached evaluations
    -h, --help               Show this help

EXAMPLES:
    $0 HEAD~5..HEAD
    $0 main..feature-branch
    $0 --system x86_64-linux abc123^..def456
    $0 --boot-stages "llvmPackages.clang,stdenv.cc" HEAD~1..HEAD
    $0 --boot-stages "llvmPackages.clang" --boot-stage-minimum 2 HEAD~1..HEAD

CACHE LOCATION: $CACHE_DIR
EOF
	exit 0
}

CLEAR_CACHE=0
while [[ $# -gt 0 ]]; do
	case $1 in
	--system)
		if [ -z "${2:-}" ]; then
			echo "Error: --system requires an argument"
			exit 1
		fi
		SYSTEM="$2"
		shift 2
		;;
	--jobs)
		if [ -z "${2:-}" ]; then
			echo "Error: --jobs requires an argument"
			exit 1
		fi
		if ! [[ $2 =~ ^[0-9]+$ ]] || [ "$2" -le 0 ]; then
			echo "Error: --jobs must be a positive integer, got: $2"
			exit 1
		fi
		MAX_JOBS="$2"
		shift 2
		;;
	--boot-stages)
		if [ -z "${2:-}" ]; then
			echo "Error: --boot-stages requires an argument"
			exit 1
		fi
		BOOT_STAGES="$2"
		shift 2
		;;
	--boot-stage-minimum)
		if [ -z "${2:-}" ]; then
			echo "Error: --boot-stage-minimum requires an argument"
			exit 1
		fi
		if ! [[ $2 =~ ^[0-9]+$ ]]; then
			echo "Error: --boot-stage-minimum must be a non-negative integer, got: $2"
			exit 1
		fi
		BOOT_STAGE_MINIMUM="$2"
		shift 2
		;;
	--clear-cache)
		CLEAR_CACHE=1
		shift
		;;
	-h | --help) usage ;;
	-*)
		echo "Error: Unknown option: $1"
		echo ""
		usage
		;;
	*)
		if [ -n "${COMMIT_RANGE:-}" ]; then
			echo "Error: Multiple commit ranges specified: '$COMMIT_RANGE' and '$1'"
			exit 1
		fi
		COMMIT_RANGE="$1"
		shift
		;;
	esac
done

if [ -z "${COMMIT_RANGE:-}" ]; then
	echo "Error: commit range required"
	usage
fi

if ! git rev-parse --git-dir >/dev/null 2>&1; then
	echo -e "${RED}Error: Not in a git repository${NC}"
	exit 1
fi

if [ -z "$SYSTEM" ]; then
	SYSTEM=$(2>/dev/null nix-instantiate --eval -E 'builtins.currentSystem' | tr -d '"')
fi

if [ $CLEAR_CACHE -eq 1 ]; then
	echo -e "${YELLOW}Clearing cache...${NC}"
	rm -rf "$CACHE_DIR"
fi

mkdir -p "$CACHE_DIR"

echo -e "${BLUE}Extracting commits from range: $COMMIT_RANGE${NC}"

BASE_COMMIT=$(git rev-list --max-count=1 "${COMMIT_RANGE%%..*}^" 2>/dev/null || git rev-list --max-count=1 "${COMMIT_RANGE%%..*}")
mapfile -t COMMITS < <(git rev-list --reverse "$COMMIT_RANGE")
ALL_COMMITS=("$BASE_COMMIT" "${COMMITS[@]}")

echo -e "\n${YELLOW}Will evaluate ${#ALL_COMMITS[@]} commits (including base)${NC}\n"
for i in "${!ALL_COMMITS[@]}"; do
	commit="${ALL_COMMITS[$i]}"
	if [ "$i" -eq 0 ]; then
		marker="${GREEN}[BASE]${NC}"
	else
		marker="[$((i))]   "
	fi
	echo -e "  $marker $(git log --oneline --no-decorate -1 "$commit")"
done

echo ""
read -p "Continue with evaluation? [y/N] " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
	echo "Aborted."
	exit 0
fi

get_cache_suffix() {
	local suffix="${SYSTEM}"
	if [ -n "$BOOT_STAGES" ]; then
		local boot_hash
		boot_hash=$(echo -n "${BOOT_STAGES}:${BOOT_STAGE_MINIMUM}" | sha256sum | cut -c1-8)
		suffix="${SYSTEM}-boot-${boot_hash}"
	fi
	echo "$suffix"
}

create_eval_expr() {
	local worktree=$1

	cat >"$worktree/eval-expr.nix" <<'EOF'
{ system ? builtins.currentSystem
, bootStages ? ""
, bootStageMinimum ? ""
}:
let
  pkgs = import ./. {
    inherit system;
    config.allowAliases = false;
  };
  lib = pkgs.lib;

  # Why tryEval wrapper: many packages fail to evaluate (unsupported platforms, broken deps)
  # We want to collect what successfully evaluates rather than failing entirely
  optionalsWithSuccess = toTry: next:
    let tried = builtins.tryEval toTry;
    in lib.optionals tried.success (next tried.value);

  findAll = path: obj:
    optionalsWithSuccess obj (obj:
      if obj ? outPath then
        optionalsWithSuccess (obj.outPath or null) (outPath:
          # Why filter: only track packages that would actually build
          # Broken/unavailable packages shouldn't count as "changed" in rebuilds
          lib.optional (
            !((obj ? meta) && (!obj.meta.available or true || obj.meta.broken or false))
          ) {
            p = path;
            o = outPath;
          }
        )
      else if (obj.recurseForDerivations or false) || (obj.recurseForRelease or false) then
        lib.concatLists (
          lib.mapAttrsToList (
            name: value: findAll (if path == null then name else path + "." + name) value
          ) obj
        )
      else
        [ ]
    );

  # Boot stages support: traverse stdenv.__bootPackages chain
  bootStagesEnabled = bootStages != "";
  bootAttrPaths = if bootStagesEnabled
    then lib.splitString "," bootStages
    else [];

  bootStageMin =
    if bootStageMinimum == "" then 0
    else lib.toInt bootStageMinimum;

  # Traverse the __bootPackages chain to count stages
  # Returns a list of pkgs from earliest (most __bootPackages) to final (pkgs)
  collectStages =
    let
      # Recursively traverse backwards, building list from current to earliest
      go = current: acc:
        let
          # Stop if we hit the postStage sentinel (__raw = true)
          isRaw = current.__raw or false;
          bootPackages = if !isRaw
            then builtins.tryEval ((current.stdenv or {}).__bootPackages or null)
            else { success = false; value = null; };
          bootIsRaw = if bootPackages.success && bootPackages.value != null
            then bootPackages.value.__raw or false
            else false;
          hasBootPackages = bootPackages.success && bootPackages.value != null && !bootIsRaw;
        in
          if hasBootPackages
          then go bootPackages.value ([current] ++ acc)
          else ([current] ++ acc);
    in
      go pkgs [];

  stages = if bootStagesEnabled then collectStages else [];

  # Build boot stage attributes with string keys
  # Creates: { bootStage0 = { "llvmPackages.clang" = derivation; recurseForDerivations = true; }; ... }
  # Uses tryEval so missing/broken attributes become null instead of crashing
  # Filters stages based on bootStageMin (e.g., if bootStageMin=2, only include stages 2+)
  bootStageAttrs =
    if bootStagesEnabled
    then lib.listToAttrs (
      lib.filter (x: x != null) (
        lib.imap0 (idx: stage:
          if idx < bootStageMin
          then null
          else lib.nameValuePair "__bootStage${toString idx}" (
            (lib.listToAttrs (
              map (attrPath:
                let
                  parts = lib.splitString "." attrPath;
                  tried = builtins.tryEval (lib.attrByPath parts null stage);
                  value = if tried.success then tried.value else null;
                in
                  lib.nameValuePair attrPath value
              ) bootAttrPaths
            )) // { recurseForDerivations = true; }
          )
        ) stages
      )
    )
    else {};

  # Why mark root as recurseForDerivations: ensures we traverse the entire pkgs tree
  root = pkgs // bootStageAttrs // { recurseForDerivations = true; };
in
findAll null root
EOF
}

evaluate_commit() {
	local commit=$1

	# Why use tree hash: enables cache hits when commit hash differs but content is identical
	# (e.g. after rebasing, amending messages, or reordering commits)
	local tree_hash
	tree_hash=$(git rev-parse "$commit^{tree}")
	local cache_suffix
	cache_suffix=$(get_cache_suffix)
	local cache_file="$CACHE_DIR/${tree_hash}-${cache_suffix}.json"

	if [ -f "$cache_file" ]; then
		echo -e "${GREEN}Using cached: $commit (tree: ${tree_hash:0:12})${NC}"
		return 0
	fi

	echo -e "${YELLOW}Evaluating: $commit (tree: ${tree_hash:0:12})${NC}"

	# Why worktree: allows evaluating different commits in parallel without checkout conflicts
	local worktree="${WORKTREE_DIR}-${commit}"
	git worktree add -q --detach "$worktree" "$commit"

	create_eval_expr "$worktree"

	local eval_result=0
	(
		cd "$worktree"

		# Why nix-instantiate instead of nix-eval-jobs:
		# We initially tried nix-eval-jobs with workers, but it was somehow slower than single-threaded eval:
		#   nix-eval-jobs --workers 10 --max-memory-size 5000 --force-recurse --no-instantiate \
		#     -I . pkgs/top-level/release.nix --arg supportedSystems "[\"$SYSTEM\"]"
		# The multi-threading overhead appeared to hurt more than help for nixpkgs evaluation.
		# Simple nix-instantiate is faster and has fewer dependencies.

		local boot_args=""
		if [ -n "$BOOT_STAGES" ]; then
			boot_args="--argstr bootStages '$BOOT_STAGES' --argstr bootStageMinimum '$BOOT_STAGE_MINIMUM'"
		fi

		eval "nix-instantiate --eval --strict --json \
            ./eval-expr.nix \
            --argstr system '$SYSTEM' \
            $boot_args \
            2>'${cache_file}.stderr' >'$cache_file'"
	) || eval_result=$?

	if [ $eval_result -ne 0 ]; then
		echo -e "${RED}Failed: $commit${NC}"
		echo "See: ${cache_file}.stderr"
		cat "${cache_file}.stderr"
		rm -f "$cache_file"
		git worktree remove -f "$worktree" 2>/dev/null || true
		return 1
	fi

	if [ -s "${cache_file}.stderr" ]; then
		echo -e "${YELLOW}Warnings: ${cache_file}.stderr${NC}"
	fi

	git worktree remove -f "$worktree" 2>/dev/null || true
	echo -e "${GREEN}Cached: $commit (tree: ${tree_hash:0:12})${NC}"
}

extract_paths() {
	local json_file=$1
	jq -r '.[] | "\(.p)\t\(.o)"' "$json_file" 2>/dev/null | sort
}

compare_commits() {
	local old_commit=$1
	local new_commit=$2

	local old_tree
	old_tree=$(git rev-parse "$old_commit^{tree}")
	local new_tree
	new_tree=$(git rev-parse "$new_commit^{tree}")

	local cache_suffix
	cache_suffix=$(get_cache_suffix)
	local old_file="$CACHE_DIR/${old_tree}-${cache_suffix}.json"
	local new_file="$CACHE_DIR/${new_tree}-${cache_suffix}.json"

	local old_paths="/tmp/eval-diff-old-$$"
	local new_paths="/tmp/eval-diff-new-$$"

	extract_paths "$old_file" >"$old_paths"
	extract_paths "$new_file" >"$new_paths"

	local old_attrs="/tmp/eval-diff-old-attrs-$$"
	local new_attrs="/tmp/eval-diff-new-attrs-$$"
	cut -f1 "$old_paths" | sort >"$old_attrs"
	cut -f1 "$new_paths" | sort >"$new_attrs"

	# Truly added/removed packages (attribute path appears or disappears)
	local added_list="/tmp/eval-diff-added-$$"
	local removed_list="/tmp/eval-diff-removed-$$"
	comm -13 "$old_attrs" "$new_attrs" >"$added_list"
	comm -23 "$old_attrs" "$new_attrs" >"$removed_list"
	local added
	added=$(wc -l <"$added_list")
	local removed
	removed=$(wc -l <"$removed_list")

	# Changed: present in both but different outPath
	local changed_list="/tmp/eval-diff-changed-$$"
	join "$old_paths" "$new_paths" | awk '$2 != $3 {print $1}' >"$changed_list"
	local changed
	changed=$(wc -l <"$changed_list")

	local commit_msg
	commit_msg=$(git log --oneline --no-decorate -1 "$new_commit")
	local commit_hash
	commit_hash=$(git rev-parse --short "$new_commit")

	{
		printf "${BLUE}%-10s${NC} (+%-4d -%-4d ~%-4d) %s\n" "$commit_hash" "$added" "$removed" "$changed" "$(git log --format=%s -1 "$new_commit")"
	} >&2

	# Output: added removed changed added_list removed_list changed_list (temp file paths)
	echo "$added $removed $changed $added_list $removed_list $changed_list"

	# Don't cleanup temp files yet - caller will use them for markdown
}

export -f evaluate_commit
export -f create_eval_expr
export -f get_cache_suffix
export CACHE_DIR SYSTEM BOOT_STAGES BOOT_STAGE_MINIMUM WORKTREE_DIR RED GREEN YELLOW BLUE NC

echo -e "\n${BLUE}Starting evaluations (max $MAX_JOBS parallel)${NC}\n"

# parallel: evaluations are CPU-bound and independent, parallelizing saves significant time
# --line-buffer --tag: stream output as it happens, prefix with commit hash for clarity
printf '%s\n' "${ALL_COMMITS[@]}" | parallel -j "$MAX_JOBS" --line-buffer --tag evaluate_commit {} || exit 1

echo ""

successful_evals=0
cache_suffix=$(get_cache_suffix)
for commit in "${ALL_COMMITS[@]}"; do
	tree_hash=$(git rev-parse "$commit^{tree}")
	cache_file="$CACHE_DIR/${tree_hash}-${cache_suffix}.json"
	if [ -f "$cache_file" ]; then
		((successful_evals++)) || true
	fi
done

if [ "$successful_evals" -lt 2 ]; then
	echo -e "${RED}Error: Need at least 2 successful evaluations to compare${NC}"
	exit 1
fi

echo -e "${BLUE}Comparing commits...${NC}\n"

# Start markdown report - use consistent path based on commit range
base_short=$(git rev-parse --short "$BASE_COMMIT")
final_short=$(git rev-parse --short "${ALL_COMMITS[-1]}")
MARKDOWN_REPORT="$CACHE_DIR/eval-diff-${base_short}..${final_short}-${SYSTEM}.md"

cat >"$MARKDOWN_REPORT" <<EOF
## nix-eval-diff report

**Range:** \`$base_short..$final_short\` (${#COMMITS[@]} commits)  
**System:** \`$SYSTEM\`  
**Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")  
EOF

# We'll add overall impact after all commits are processed
declare -a COMMIT_MARKDOWN_SECTIONS

for ((i = 1; i < ${#ALL_COMMITS[@]}; i++)); do
	old_commit="${ALL_COMMITS[$((i - 1))]}"
	new_commit="${ALL_COMMITS[$i]}"

	results=$(compare_commits "$old_commit" "$new_commit")
	read -r added removed changed added_list removed_list changed_list <<<"$results"

	# Build markdown section for this commit
	commit_hash=$(git rev-parse --short "$new_commit")
	commit_msg=$(git log --format=%s -1 "$new_commit")

	commit_section="<details>
<summary>$commit_hash $commit_msg — <b>+$added -$removed ~$changed</b></summary>

"

	# Add package details if any exist
	if [ "$added" -gt 0 ] || [ "$removed" -gt 0 ] || [ "$changed" -gt 0 ]; then
		if [ "$added" -gt 0 ]; then
			commit_section+="<details>
<summary>Added packages ($added)</summary>

\`\`\`
$(cat "$added_list")
\`\`\`

</details>
"
		fi

		if [ "$removed" -gt 0 ]; then
			commit_section+="<details>
<summary>Removed packages ($removed)</summary>

\`\`\`
$(cat "$removed_list")
\`\`\`

</details>

"
		fi

		if [ "$changed" -gt 0 ]; then
			commit_section+="<details>
<summary>Changed packages ($changed)</summary>

\`\`\`
$(cat "$changed_list")
\`\`\`

</details>  
"
		fi
	fi

	commit_section+="</details>

"

	# Store for later
	COMMIT_MARKDOWN_SECTIONS[i]="$commit_section"

	rm -f "$added_list" "$removed_list" "$changed_list"
done

echo ""
echo -e "${BLUE}Summary${NC}"
echo ""

# Overall impact: direct comparison of base to final
echo "Overall Impact (base → final):"
base_tree=$(git rev-parse "$BASE_COMMIT^{tree}")
final_tree=$(git rev-parse "${ALL_COMMITS[-1]}^{tree}")
cache_suffix=$(get_cache_suffix)
base_file="$CACHE_DIR/${base_tree}-${cache_suffix}.json"
final_file="$CACHE_DIR/${final_tree}-${cache_suffix}.json"

base_paths="/tmp/eval-overall-base-$$"
final_paths="/tmp/eval-overall-final-$$"
extract_paths "$base_file" >"$base_paths"
extract_paths "$final_file" >"$final_paths"

base_attrs="/tmp/eval-overall-base-attrs-$$"
final_attrs="/tmp/eval-overall-final-attrs-$$"
cut -f1 "$base_paths" | sort >"$base_attrs"
cut -f1 "$final_paths" | sort >"$final_attrs"

overall_added=$(comm -13 "$base_attrs" "$final_attrs" | wc -l)
overall_removed=$(comm -23 "$base_attrs" "$final_attrs" | wc -l)
overall_changed=$(join "$base_paths" "$final_paths" | awk '$2 != $3' | wc -l)

printf "  Added:   ${GREEN}%'d${NC} packages\n" "$overall_added"
printf "  Removed: ${GREEN}%'d${NC} packages\n" "$overall_removed"
printf "  Rebuilt: ${GREEN}%'d${NC} packages\n" "$overall_changed"
rm -f "$base_paths" "$final_paths" "$base_attrs" "$final_attrs"

echo ""

# Now write overall impact and consolidated per-commit info to markdown
cat >>"$MARKDOWN_REPORT" <<EOF
**Overall Impact:** +$overall_added -$overall_removed ~$overall_changed packages

## Per-Commit Breakdown

EOF

# Write each commit as an expandable section
for ((i = 1; i < ${#ALL_COMMITS[@]}; i++)); do
	echo "${COMMIT_MARKDOWN_SECTIONS[$i]}" >>"$MARKDOWN_REPORT"
done

echo -e "${GREEN}Done!${NC}"
echo -e "Cache: $CACHE_DIR"
echo -e "Report: $MARKDOWN_REPORT"
